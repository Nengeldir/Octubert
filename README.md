# Octubert

**Octubert** is an advanced symbolic music generation model based on the [absorbing state diffusion framework](https://github.com/samb-t/unleashing-transformers).

It is an evolution of the original **SCHmUBERT** model, introducing **Octuple MIDI Encoding** and **Natural Partial Masking** to enable high-fidelity musical control and inpainting.

## Additions

### 1. Octuple MIDI Encoding
Standard MIDI representations often treat note attributes (like pitch and duration) as separate, loosely coupled tokens. Octubert uses an **Octuple Token** representation (inspired by MusicBERT), where each musical event is encoded as a single, unified 8-tuple:
*   `(Bar, Position, Program, Pitch, Duration, Velocity, TimeSignature, Tempo)`

This tightly coupled representation allows the transformer to learn the intricate relationships between musical attributesâ€”understanding that a specific pitch often correlates with a certain duration or velocity in a given rhythmic context.

### 2. Natural Partial Masking
Traditional masked language models (like BERT) mask entire tokens. Because our tokens are Octuples, masking the whole token would hide all information about a note.

**Octubert introduces Natural Partial Masking**, which allows us to mask *specific attributes* of a token while keeping others visible.
*   **Musical Inpainting**: We can mask just the *Pitch* of a phrase while keeping the *Rhythm* (Duration/Position) intact, effectively asking the model to "re-harmonize" a rhythm.
*   **Flexible Strategies**:
    *   `rand_attribute`: Randomly masks attributes (e.g., Velocity or Tempo) to learn their distributions.
    *   `1_bar_all`: Masks all attributes for a full bar to learn structural coherence.
    *   `mixed`: A robust curriculum that combines disparate masking strategies for generalized learning.

### 3. Structural Continuity
Built-in support for **Music Infilling** allows you to seamlessly generate bridges or fill gaps in existing MIDI files, maintaining the tempo and style of the surrounding context.

---

## Installation

The environment is managed via Conda.

```bash
conda env create -f env.yml
conda activate symbolic-music-discrete-diffusion
```

*Note: A soundfont file `soundfont.sf2` (not included) must be placed in the project root for audio rendering functionalities.*

## Usage

### 1. Data Preparation
Octubert requires valid Octuple-encoded data. We recommend the POP909 dataset.

```bash
python prepare_data.py --root_dir data/POP909 --target data/POP909_melody.npy --mode melody --bars 64
```
*This uses our improved pre-processing pipeline that prevents data fragmentation by handling silences and tempo changes intelligently.*

### 2. Training
To train an Octubert model with the **Mixed** masking strategy (recommended):

```bash
python train.py --dataset data/POP909_melody.npy --bars 64 --batch_size 16 --tracks melody --model octuple_mixed --masking_strategy mixed
```

### 3. Infilling (The "Magic" Step)
To take an existing song (`input.mid`) and fill in a gap (e.g., bars 16-32) with new music:

```bash
python infill.py --load_dir logs/log_octuple_mixed_melody_1024 --input_midi input.mid --start_bar 16 --end_bar 32
```

### 4. Interactive GUI
Launch the web-based GUI for interactive sampling and visualization:

```bash
python sample.py --load_step 140000 --bars 64 --tracks trio --model conv_transformer
```

---

## Attribution
This project is built upon the foundational work of **SCHmUBERT**.
*   Original implementation: [SCHmUBERT](https://github.com/plassma/symbolic-music-discrete-diffusion) (based on [unleashing-transformers](https://github.com/samb-t/unleashing-transformers)).
*   Octuple MIDI implementation adapted from MusicBERT.

## Evaluate

### Fast training/eval loop

To evaluate the framewise self-similarity metric on the samples generated by a model, run:

```python evaluate.py --mode unconditional|infilling|self```

### Structure-aware metrics (unconditional + infilling)

A more detailed, structure-aware evaluator lives in [docs/EVALUATION.md](docs/EVALUATION.md). It uses `evaluate_metrics.py` to generate samples or infills and compute distributional + structural metrics (JS, self-similarity, key consistency, masked infill accuracy, optional structural FAD). See that doc for commands and options.
